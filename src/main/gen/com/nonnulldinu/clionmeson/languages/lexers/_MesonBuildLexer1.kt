/* The following code was generated by JFlex 1.7.0 tweaked for IntelliJ platform */
package com.nonnulldinu.clionmeson.languages.lexers

import com.intellij.lexer.FlexLexer
import com.intellij.psi.TokenType
import com.intellij.psi.tree.IElementType
import java.io.IOException
import java.io.Reader

/**
 * This class is a scanner generated by
 * [JFlex](http://www.jflex.de/) 1.7.0
 * from the specification file <tt>_MesonBuildLexer.flex</tt>
 */
class _MesonBuildLexer
/**
 * Creates a new scanner
 *
 * @param   in  the java.io.Reader to read input from.
 */
/* user code: */ @JvmOverloads constructor(
        /** the input device  */
        private val zzReader: Reader? = null as Reader?) : FlexLexer {

    /** the current state of the DFA  */
    private var zzState = 0

    /** the current lexical state  */
    private var zzLexicalState = YYINITIAL

    /** this buffer contains the current text to be matched and is
     * the source of the yytext() string  */
    private var zzBuffer: CharSequence = ""

    /** the textposition at the last accepting state  */
    private var zzMarkedPos = 0

    /** the current text position in the buffer  */
    private var zzCurrentPos = 0

    /** startRead marks the beginning of the yytext() string in the buffer  */
    private var zzStartRead = 0

    /** endRead marks the last character in the buffer, that has been read
     * from input  */
    private var zzEndRead = 0

    /**
     * zzAtBOL == true <=> the scanner is currently at the beginning of a line
     */
    private var zzAtBOL = true

    /** zzAtEOF == true <=> the scanner is at the EOF  */
    private var zzAtEOF = false

    /** denotes if the user-EOF-code has already been executed  */
    private val zzEOFDone = false
    override fun getTokenStart(): Int {
        return zzStartRead
    }

    override fun getTokenEnd(): Int {
        return tokenStart + yylength()
    }

    override fun reset(buffer: CharSequence, start: Int, end: Int, initialState: Int) {
        zzBuffer = buffer
        zzStartRead = start
        zzMarkedPos = zzStartRead
        zzCurrentPos = zzMarkedPos
        zzAtEOF = false
        zzAtBOL = true
        zzEndRead = end
        yybegin(initialState)
    }

    /**
     * Refills the input buffer.
     *
     * @return      `false`, iff there was new input.
     *
     * @exception   java.io.IOException  if any I/O-Error occurs
     */
    @Throws(IOException::class)
    private fun zzRefill(): Boolean {
        return true
    }

    /**
     * Returns the current lexical state.
     */
    override fun yystate(): Int {
        return zzLexicalState
    }

    /**
     * Enters a new lexical state
     *
     * @param newState the new lexical state
     */
    override fun yybegin(newState: Int) {
        zzLexicalState = newState
    }

    /**
     * Returns the text matched by the current regular expression.
     */
    fun yytext(): CharSequence {
        return zzBuffer.subSequence(zzStartRead, zzMarkedPos)
    }

    /**
     * Returns the character at position `pos` from the
     * matched text.
     *
     * It is equivalent to yytext().charAt(pos), but faster
     *
     * @param pos the position of the character to fetch.
     * A value from 0 to yylength()-1.
     *
     * @return the character at position pos
     */
    fun yycharat(pos: Int): Char {
        return zzBuffer[zzStartRead + pos]
    }

    /**
     * Returns the length of the matched text region.
     */
    fun yylength(): Int {
        return zzMarkedPos - zzStartRead
    }

    /**
     * Reports an error that occurred while scanning.
     *
     * In a wellformed scanner (no or only correct usage of
     * yypushback(int) and a match-all fallback rule) this method
     * will only be called with things that "Can't Possibly Happen".
     * If this method is called, something is seriously wrong
     * (e.g. a JFlex bug producing a faulty scanner etc.).
     *
     * Usual syntax/scanner level error handling should be done
     * in error fallback rules.
     *
     * @param   errorCode  the code of the errormessage to display
     */
    private fun zzScanError(errorCode: Int) {
        val message: String
        message = try {
            ZZ_ERROR_MSG[errorCode]
        } catch (e: ArrayIndexOutOfBoundsException) {
            ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR]
        }
        throw Error(message)
    }

    /**
     * Pushes the specified amount of characters back into the input stream.
     *
     * They will be read again by then next call of the scanning method
     *
     * @param number  the number of characters to be read again.
     * This number must not be greater than yylength()!
     */
    fun yypushback(number: Int) {
        if (number > yylength()) zzScanError(ZZ_PUSHBACK_2BIG)
        zzMarkedPos -= number
    }

    /**
     * Resumes scanning until the next regular expression is matched,
     * the end of input is encountered or an I/O-Error occurs.
     *
     * @return      the next token
     * @exception   java.io.IOException  if any I/O-Error occurs
     */
    @Throws(IOException::class)
    override fun advance(): IElementType {
        var zzInput: Int
        var zzAction: Int

        // cached fields:
        var zzCurrentPosL: Int
        var zzMarkedPosL: Int
        var zzEndReadL = zzEndRead
        var zzBufferL = zzBuffer
        val zzTransL = ZZ_TRANS
        val zzRowMapL = ZZ_ROWMAP
        val zzAttrL = ZZ_ATTRIBUTE
        while (true) {
            zzMarkedPosL = zzMarkedPos
            zzAction = -1
            zzStartRead = zzMarkedPosL
            zzCurrentPos = zzStartRead
            zzCurrentPosL = zzCurrentPos
            zzState = ZZ_LEXSTATE[zzLexicalState]

            // set up zzAction for empty match case:
            var zzAttributes = zzAttrL[zzState]
            if (zzAttributes and 1 == 1) {
                zzAction = zzState
            }
            zzForAction@{
                while (true) {
                    if (zzCurrentPosL < zzEndReadL) {
                        zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL /*, zzEndReadL*/)
                        zzCurrentPosL += Character.charCount(zzInput)
                    } else if (zzAtEOF) {
                        zzInput = YYEOF
                        break@zzForAction
                    } else {
                        // store back cached positions
                        zzCurrentPos = zzCurrentPosL
                        zzMarkedPos = zzMarkedPosL
                        val eof = zzRefill()
                        // get translated positions and possibly new buffer
                        zzCurrentPosL = zzCurrentPos
                        zzMarkedPosL = zzMarkedPos
                        zzBufferL = zzBuffer
                        zzEndReadL = zzEndRead
                        if (eof) {
                            zzInput = YYEOF
                            break@zzForAction
                        } else {
                            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL /*, zzEndReadL*/)
                            zzCurrentPosL += Character.charCount(zzInput)
                        }
                    }
                    val zzNext = zzTransL[zzRowMapL[zzState] + ZZ_CMAP(zzInput)]
                    if (zzNext == -1) break@zzForAction
                    zzState = zzNext
                    zzAttributes = zzAttrL[zzState]
                    if (zzAttributes and 1 == 1) {
                        zzAction = zzState
                        zzMarkedPosL = zzCurrentPosL
                        if (zzAttributes and 8 == 8) break@zzForAction
                    }
                }
            }

            // store back cached position
            zzMarkedPos = zzMarkedPosL
            if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
                zzAtEOF = true
                return null
            } else {
                when (if (zzAction < 0) zzAction else ZZ_ACTION[zzAction]) {
                    1 -> {
                        return TokenType.BAD_CHARACTER
                    }
                    56 -> {
                    }
                    2 -> {
                        return TokenType.WHITE_SPACE
                    }
                    57 -> {
                    }
                    3 -> {
                        return NEWLINE
                    }
                    58 -> {
                    }
                    4 -> {
                        return OCTNUM
                    }
                    59 -> {
                    }
                    5 -> {
                        return ID
                    }
                    60 -> {
                    }
                    6 -> {
                        return DECNUM
                    }
                    61 -> {
                    }
                    7 -> {
                        return BRACE_BEGIN
                    }
                    62 -> {
                    }
                    8 -> {
                        return BRACE_END
                    }
                    63 -> {
                    }
                    9 -> {
                        return CURLY_BRACE_BEGIN
                    }
                    64 -> {
                    }
                    10 -> {
                        return CURLY_BRACE_END
                    }
                    65 -> {
                    }
                    11 -> {
                        return PAREN_BEGIN
                    }
                    66 -> {
                    }
                    12 -> {
                        return PAREN_END
                    }
                    67 -> {
                    }
                    13 -> {
                        return COMMA
                    }
                    68 -> {
                    }
                    14 -> {
                        return ATR_OP
                    }
                    69 -> {
                    }
                    15 -> {
                        return COMP_OP4
                    }
                    70 -> {
                    }
                    16 -> {
                        return COMP_OP5
                    }
                    71 -> {
                    }
                    17 -> {
                        return MULT_OP
                    }
                    72 -> {
                    }
                    18 -> {
                        return DIV_OP
                    }
                    73 -> {
                    }
                    19 -> {
                        return MOD_OP
                    }
                    74 -> {
                    }
                    20 -> {
                        return PLUS_OP
                    }
                    75 -> {
                    }
                    21 -> {
                        return MINUS_OP
                    }
                    76 -> {
                    }
                    22 -> {
                        return LANG_TOKEN_QMARK
                    }
                    77 -> {
                    }
                    23 -> {
                        return LANG_TOKEN_COLON
                    }
                    78 -> {
                    }
                    24 -> {
                        return LANG_TOKEN_DOT
                    }
                    79 -> {
                    }
                    25 -> {
                    }
                    80 -> {
                    }
                    26 -> {
                        return STRSIMPLE
                    }
                    81 -> {
                    }
                    27 -> {
                        return LINE_COMMENT
                    }
                    82 -> {
                    }
                    28 -> {
                        return IN_OP
                    }
                    83 -> {
                    }
                    29 -> {
                        return LANG_TOKEN_IF
                    }
                    84 -> {
                    }
                    30 -> {
                        return COMP_OP1
                    }
                    85 -> {
                    }
                    31 -> {
                        return COMP_OP2
                    }
                    86 -> {
                    }
                    32 -> {
                        return COMP_OP3
                    }
                    87 -> {
                    }
                    33 -> {
                        return COMP_OP6
                    }
                    88 -> {
                    }
                    34 -> {
                        return COMP_ATR_OP1
                    }
                    89 -> {
                    }
                    35 -> {
                        return COMP_ATR_OP2
                    }
                    90 -> {
                    }
                    36 -> {
                        return COMP_ATR_OP3
                    }
                    91 -> {
                    }
                    37 -> {
                        return COMP_ATR_OP4
                    }
                    92 -> {
                    }
                    38 -> {
                        return COMP_ATR_OP5
                    }
                    93 -> {
                    }
                    39 -> {
                        return LANG_TOKEN_OR
                    }
                    94 -> {
                    }
                    40 -> {
                        return BINNUM
                    }
                    95 -> {
                    }
                    41 -> {
                        return HEXNUM
                    }
                    96 -> {
                    }
                    42 -> {
                        yybegin(MULTILINE_STRING)
                    }
                    97 -> {
                    }
                    43 -> {
                        return LANG_TOKEN_NOT
                    }
                    98 -> {
                    }
                    44 -> {
                        return LANG_TOKEN_AND
                    }
                    99 -> {
                    }
                    45 -> {
                        yybegin(YYINITIAL)
                        return STRMULTILINE
                    }
                    100 -> {
                    }
                    46 -> {
                        return BLOCK_COMMENT
                    }
                    101 -> {
                    }
                    47 -> {
                        return BOOL_LITERAL_TRUE
                    }
                    102 -> {
                    }
                    48 -> {
                        return LANG_TOKEN_ELSE_IF
                    }
                    103 -> {
                    }
                    49 -> {
                        return LANG_TOKEN_ELSE
                    }
                    104 -> {
                    }
                    50 -> {
                        return LANG_TOKEN_JUMP_BREAK
                    }
                    105 -> {
                    }
                    51 -> {
                        return LANG_TOKEN_ENDIF
                    }
                    106 -> {
                    }
                    52 -> {
                        return BOOL_LITERAL_FALSE
                    }
                    107 -> {
                    }
                    53 -> {
                        return LANG_TOKEN_FOREACH
                    }
                    108 -> {
                    }
                    54 -> {
                        return LANG_TOKEN_JUMP_CONTINUE
                    }
                    109 -> {
                    }
                    55 -> {
                        return LANG_TOKEN_FOREACH_END
                    }
                    110 -> {
                    }
                    else -> zzScanError(ZZ_NO_MATCH)
                }
            }
        }
    }

    companion object {
        /** This character denotes the end of file  */
        const val YYEOF = -1

        /** initial size of the lookahead buffer  */
        private const val ZZ_BUFFERSIZE = 16384

        /** lexical states  */
        const val YYINITIAL = 0
        const val MULTILINE_STRING = 2

        /**
         * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
         * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
         * at the beginning of a line
         * l is of the form l = 2*k, k a non negative integer
         */
        private val ZZ_LEXSTATE = intArrayOf(
                0, 0, 1, 1
        )

        /**
         * Translates characters to character classes
         * Chosen bits are [7, 7, 7]
         * Total runtime size is 1928 bytes
         */
        fun ZZ_CMAP(ch: Int): Int {
            return ZZ_CMAP_A[ZZ_CMAP_Y[ZZ_CMAP_Z[ch shr 14] or (ch shr 7 and 0x7f)] shl 7 or (ch and 0x7f)].toInt()
        }

        /* The ZZ_CMAP_Z table has 68 entries */
        val ZZ_CMAP_Z = zzUnpackCMap(
                "\u0001\u0000\u0043\u0080")

        /* The ZZ_CMAP_Y table has 256 entries */
        val ZZ_CMAP_Y = zzUnpackCMap(
                "\u0001\u0000\u0001\u0001\u002b\u0002\u0001\u0003\u0012\u0002\u0001\u0004\u001f\u0002\u0001\u0003\u009f\u0002")

        /* The ZZ_CMAP_A table has 640 entries */
        val ZZ_CMAP_A = zzUnpackCMap(
                """	      
!"1
0 / 	  (,-&'.)+$*#%   ÃŸ    /   """)

        /**
         * Translates DFA states to action switch labels.
         */
        private val ZZ_ACTION = zzUnpackAction()
        private const val ZZ_ACTION_PACKED_0 = "\u0002\u0000\u0001\u0001\u0001\u0002\u0002\u0003\u0001\u0002\u0001\u0004\u0001\u0005\u0001\u0006" +
                "\u0001\u0005\u0001\u0001\u0001\u0005\u0001\u0001\u0002\u0005\u0001\u0007\u0001\u0008\u0001\u0009" +
                "\u0001\u000a\u0001\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f\u0001\u0010\u0001\u0001" +
                "\u0001\u0011\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0006\u0005\u0001\u0016\u0001\u0017" +
                "\u0001\u0018\u0002\u0019\u0001\u0004\u0002\u0000\u0001\u0005\u0001\u0000\u0001\u001a\u0003\u0000" +
                "\u0001\u001b\u0001\u001c\u0001\u001d\u0001\u0005\u0001\u001e\u0001\u001f\u0001\u0020\u0001\u0021" +
                "\u0001\u0022\u0001\u0023\u0001\u0024\u0001\u0025\u0001\u0026\u0006\u0005\u0001\u0027\u0001\u0005" +
                "\u0001\u0000\u0001\u0028\u0001\u0029\u0001\u0005\u0001\u001a\u0001\u002a\u0001\u001a\u0003\u0000" +
                "\u0001\u002b\u0006\u0005\u0001\u002c\u0001\u0005\u0001\u002d\u0001\u0005\u0001\u002e\u0001\u002f" +
                "\u0002\u0005\u0001\u0030\u0001\u0031\u0003\u0005\u0001\u0032\u0001\u0033\u0001\u0005\u0001\u0034" +
                "\u0006\u0005\u0001\u0035\u0002\u0005\u0001\u0036\u0001\u0005\u0001\u0037"

        private fun zzUnpackAction(): IntArray {
            val result = IntArray(119)
            var offset = 0
            offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result)
            return result
        }

        private fun zzUnpackAction(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                var count = packed[i++].toInt()
                val value = packed[i++].toInt()
                do result[j++] = value while (--count > 0)
            }
            return j
        }

        /**
         * Translates a state to a row index in the transition table
         */
        private val ZZ_ROWMAP = zzUnpackRowMap()
        private const val ZZ_ROWMAP_PACKED_0 = "\u0000\u0000\u0000\u0032\u0000\u0064\u0000\u0096\u0000\u00c8\u0000\u00fa\u0000\u012c\u0000\u015e" +
                "\u0000\u0190\u0000\u01c2\u0000\u01f4\u0000\u0226\u0000\u0258\u0000\u028a\u0000\u02bc\u0000\u02ee" +
                "\u0000\u0064\u0000\u0064\u0000\u0064\u0000\u0064\u0000\u0064\u0000\u0064\u0000\u0064\u0000\u0320" +
                "\u0000\u0352\u0000\u0384\u0000\u03b6\u0000\u03e8\u0000\u041a\u0000\u044c\u0000\u047e\u0000\u04b0" +
                "\u0000\u04e2\u0000\u0514\u0000\u0546\u0000\u0578\u0000\u05aa\u0000\u05dc\u0000\u0064\u0000\u0064" +
                "\u0000\u0064\u0000\u0064\u0000\u060e\u0000\u0640\u0000\u0672\u0000\u06a4\u0000\u06d6\u0000\u0708" +
                "\u0000\u073a\u0000\u076c\u0000\u079e\u0000\u028a\u0000\u07d0\u0000\u01f4\u0000\u01f4\u0000\u0802" +
                "\u0000\u0064\u0000\u0064\u0000\u0064\u0000\u0064\u0000\u0064\u0000\u0064\u0000\u0064\u0000\u0064" +
                "\u0000\u0064\u0000\u0834\u0000\u0866\u0000\u0898\u0000\u08ca\u0000\u08fc\u0000\u092e\u0000\u01f4" +
                "\u0000\u0960\u0000\u0992\u0000\u0672\u0000\u06a4\u0000\u09c4\u0000\u0064\u0000\u0064\u0000\u0708" +
                "\u0000\u09f6\u0000\u0a28\u0000\u0a5a\u0000\u01f4\u0000\u0a8c\u0000\u0abe\u0000\u0af0\u0000\u0b22" +
                "\u0000\u0b54\u0000\u0b86\u0000\u01f4\u0000\u0bb8\u0000\u0064\u0000\u0bea\u0000\u0c1c\u0000\u01f4" +
                "\u0000\u0c4e\u0000\u0c80\u0000\u01f4\u0000\u01f4\u0000\u0cb2\u0000\u0ce4\u0000\u0d16\u0000\u01f4" +
                "\u0000\u01f4\u0000\u0d48\u0000\u01f4\u0000\u0d7a\u0000\u0dac\u0000\u0dde\u0000\u0e10\u0000\u0e42" +
                "\u0000\u0e74\u0000\u01f4\u0000\u0ea6\u0000\u0ed8\u0000\u01f4\u0000\u0f0a\u0000\u01f4"

        private fun zzUnpackRowMap(): IntArray {
            val result = IntArray(119)
            var offset = 0
            offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result)
            return result
        }

        private fun zzUnpackRowMap(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                val high = packed[i++].toInt() shl 16
                result[j++] = high or packed[i++].toInt()
            }
            return j
        }

        /**
         * The transition table of the DFA
         */
        private val ZZ_TRANS = zzUnpackTrans()
        private const val ZZ_TRANS_PACKED_0 = "\u0001\u0003\u0001\u0004\u0001\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a" +
                "\u0002\u000b\u0002\u000a\u0001\u000b\u0001\u000c\u0001\u0003\u0001\u000d\u0001\u000e\u0001\u000f" +
                "\u0001\u0010\u0001\u0011\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001\u0016\u0001\u0017" +
                "\u0001\u0018\u0001\u0019\u0001\u001a\u0001\u001b\u0001\u001c\u0001\u001d\u0001\u001e\u0001\u001f" +
                "\u0001\u0020\u0001\u0021\u0002\u000b\u0001\u0022\u0001\u0023\u0001\u0024\u0002\u000b\u0001\u0025" +
                "\u0001\u0026\u0002\u000b\u0001\u0027\u0001\u0028\u0001\u0029\u000d\u002a\u0001\u002b\u0024\u002a" +
                "\u0033\u0000\u0001\u0004\u0001\u0005\u0001\u0006\u0001\u0007\u002e\u0000\u0001\u0005\u0001\u0007" +
                "\u0001\u0005\u0001\u0007\u002e\u0000\u0001\u0006\u0001\u0005\u0001\u0006\u0001\u0007\u002e\u0000" +
                "\u0004\u0007\u0032\u0000\u0001\u002c\u0001\u002d\u0001\u002c\u0001\u002e\u0001\u0000\u0001\u002c" +
                "\u002c\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u0001\u000b" +
                "\u0001\u002f\u000a\u000b\u0008\u0000\u0001\u000a\u0001\u0000\u0001\u000a\u0002\u0000\u0002\u000a" +
                "\u002b\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u000c\u000b" +
                "\u0003\u0000\u000d\u0030\u0001\u0031\u0001\u0032\u0023\u0030\u0005\u0000\u0008\u000b\u0002\u0000" +
                "\u0001\u000d\u0001\u0033\u0002\u000b\u0010\u0000\u000c\u000b\u0003\u0000\u0002\u0034\u0002\u0035" +
                "\u002e\u0034\u0005\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0001\u000b\u0001\u0036" +
                "\u0010\u0000\u0004\u000b\u0001\u0037\u0007\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b" +
                "\u0001\u0000\u0002\u000b\u0010\u0000\u0008\u000b\u0001\u0038\u0003\u000b\u001d\u0000\u0001\u0039" +
                "\u0031\u0000\u0001\u003a\u0031\u0000\u0001\u003b\u0031\u0000\u0001\u003c\u0031\u0000\u0001\u003d" +
                "\u0031\u0000\u0001\u003e\u0031\u0000\u0001\u003f\u0031\u0000\u0001\u0040\u0031\u0000\u0001\u0041" +
                "\u001c\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u0001\u000b" +
                "\u0001\u0042\u000a\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0001\u000b" +
                "\u0001\u0043\u0010\u0000\u0006\u000b\u0001\u0044\u0005\u000b\u0008\u0000\u0008\u000b\u0002\u0000" +
                "\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u0005\u000b\u0001\u0045\u0002\u000b\u0001\u0046" +
                "\u0003\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0001\u000b\u0001\u0047" +
                "\u0010\u0000\u000c\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b" +
                "\u0010\u0000\u0001\u000b\u0001\u0048\u000a\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b" +
                "\u0001\u0000\u0002\u000b\u0010\u0000\u0008\u000b\u0001\u0049\u0003\u000b\u0010\u0000\u0001\u004a" +
                "\u0029\u0000\u0001\u002c\u0001\u0000\u0001\u002c\u0002\u0000\u0001\u002c\u002c\u0000\u0001\u004b" +
                "\u0001\u0000\u0001\u004b\u002f\u0000\u0003\u004c\u0001\u0000\u0003\u004c\u001a\u0000\u0003\u004c" +
                "\u0003\u0000\u0002\u004c\u0009\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b" +
                "\u0010\u0000\u0003\u000b\u0001\u004d\u0008\u000b\u0003\u0000\u000d\u0030\u0001\u004e\u0001\u0032" +
                "\u0023\u0030\u000d\u0000\u0001\u004f\u0024\u0000\u000d\u0030\u0001\u0050\u0001\u0032\u0023\u0030" +
                "\u0002\u0033\u0002\u0051\u002e\u0033\u0002\u0000\u0002\u0035\u000b\u0000\u0001\u0052\u0001\u0053" +
                "\u0026\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u0001\u0054" +
                "\u000b\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000" +
                "\u0002\u000b\u0001\u0055\u0009\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000" +
                "\u0002\u000b\u0010\u0000\u000a\u000b\u0001\u0056\u0001\u000b\u0008\u0000\u0008\u000b\u0002\u0000" +
                "\u0001\u000b\u0001\u0000\u0001\u0057\u0001\u000b\u0010\u0000\u0007\u000b\u0001\u0058\u0004\u000b" +
                "\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u0006\u000b" +
                "\u0001\u0059\u0005\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b" +
                "\u0010\u0000\u0001\u000b\u0001\u005a\u000a\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b" +
                "\u0001\u0000\u0002\u000b\u0010\u0000\u000a\u000b\u0001\u005b\u0001\u000b\u0008\u0000\u0008\u000b" +
                "\u0002\u0000\u0001\u000b\u0001\u0000\u0001\u000b\u0001\u005c\u0010\u0000\u000c\u000b\u0010\u0000" +
                "\u0001\u005d\u0029\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000" +
                "\u0005\u000b\u0001\u005e\u0006\u000b\u0005\u0000\u0002\u0051\u000b\u0000\u0001\u0052\u0001\u0053" +
                "\u0030\u0000\u0001\u0052\u0001\u0053\u0021\u0000\u0002\u0053\u0002\u005f\u002e\u0053\u0005\u0000" +
                "\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u0003\u000b\u0001\u0060" +
                "\u0008\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0001\u0061\u0001\u000b" +
                "\u0010\u0000\u0004\u000b\u0001\u0062\u0007\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b" +
                "\u0001\u0000\u0002\u000b\u0010\u0000\u0004\u000b\u0001\u0063\u0007\u000b\u0008\u0000\u0008\u000b" +
                "\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u0003\u000b\u0001\u0064\u0008\u000b" +
                "\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u0007\u000b" +
                "\u0001\u0065\u0004\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b" +
                "\u0010\u0000\u0003\u000b\u0001\u0066\u0008\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b" +
                "\u0001\u0000\u0002\u000b\u0010\u0000\u0001\u0067\u000b\u000b\u0008\u0000\u0008\u000b\u0002\u0000" +
                "\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u000b\u000b\u0001\u0068\u0005\u0000\u0002\u005f" +
                "\u000b\u0000\u0001\u0052\u0001\u0053\u0026\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000" +
                "\u0002\u000b\u0010\u0000\u0004\u000b\u0001\u0069\u0007\u000b\u0008\u0000\u0008\u000b\u0002\u0000" +
                "\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u0008\u000b\u0001\u006a\u0003\u000b\u0008\u0000" +
                "\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u0003\u000b\u0001\u006b" +
                "\u0008\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000" +
                "\u0005\u000b\u0001\u006c\u0006\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000" +
                "\u0001\u006d\u0001\u000b\u0010\u0000\u000c\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b" +
                "\u0001\u0000\u0002\u000b\u0010\u0000\u0001\u000b\u0001\u006e\u000a\u000b\u0008\u0000\u0008\u000b" +
                "\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u0009\u000b\u0001\u006f\u0002\u000b" +
                "\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0001\u000b\u0001\u0070\u0010\u0000" +
                "\u000c\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000" +
                "\u0003\u000b\u0001\u0071\u0008\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u0072\u0001\u0000" +
                "\u0002\u000b\u0010\u0000\u000c\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000" +
                "\u0002\u000b\u0010\u0000\u0002\u000b\u0001\u0073\u0009\u000b\u0008\u0000\u0008\u000b\u0002\u0000" +
                "\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u0005\u000b\u0001\u0074\u0006\u000b\u0008\u0000" +
                "\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000\u0003\u000b\u0001\u0075" +
                "\u0008\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u000b\u0001\u0000\u0002\u000b\u0010\u0000" +
                "\u0009\u000b\u0001\u0076\u0002\u000b\u0008\u0000\u0008\u000b\u0002\u0000\u0001\u0077\u0001\u0000" +
                "\u0002\u000b\u0010\u0000\u000c\u000b\u0003\u0000"

        private fun zzUnpackTrans(): IntArray {
            val result = IntArray(3900)
            var offset = 0
            offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result)
            return result
        }

        private fun zzUnpackTrans(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                var count = packed[i++].toInt()
                var value = packed[i++].toInt()
                value--
                do result[j++] = value while (--count > 0)
            }
            return j
        }

        /* error codes */
        private const val ZZ_UNKNOWN_ERROR = 0
        private const val ZZ_NO_MATCH = 1
        private const val ZZ_PUSHBACK_2BIG = 2

        /* error messages for the codes above */
        private val ZZ_ERROR_MSG = arrayOf(
                "Unknown internal scanner error",
                "Error: could not match input",
                "Error: pushback value was too large"
        )

        /**
         * ZZ_ATTRIBUTE[aState] contains the attributes of state `aState`
         */
        private val ZZ_ATTRIBUTE = zzUnpackAttribute()
        private const val ZZ_ATTRIBUTE_PACKED_0 = "\u0002\u0000\u0001\u0009\u000d\u0001\u0007\u0009\u000f\u0001\u0004\u0009\u0002\u0001\u0002\u0000" +
                "\u0001\u0001\u0001\u0000\u0001\u0001\u0003\u0000\u0004\u0001\u0009\u0009\u0008\u0001\u0001\u0000" +
                "\u0003\u0001\u0002\u0009\u0001\u0001\u0003\u0000\u0009\u0001\u0001\u0009\u001a\u0001"

        private fun zzUnpackAttribute(): IntArray {
            val result = IntArray(119)
            var offset = 0
            offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result)
            return result
        }

        private fun zzUnpackAttribute(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                var count = packed[i++].toInt()
                val value = packed[i++].toInt()
                do result[j++] = value while (--count > 0)
            }
            return j
        }

        /**
         * Unpacks the compressed character translation table.
         *
         * @param packed   the packed character translation table
         * @return         the unpacked character translation table
         */
        private fun zzUnpackCMap(packed: String): CharArray {
            var size = 0
            run {
                var i = 0
                val length = packed.length
                while (i < length) {
                    size += packed[i].toInt()
                    i += 2
                }
            }
            val map = CharArray(size)
            var i = 0 /* index in packed string  */
            var j = 0 /* index in unpacked array */
            while (i < packed.length) {
                var count = packed[i++].toInt()
                val value = packed[i++]
                do map[j++] = value while (--count > 0)
            }
            return map
        }
    }

}